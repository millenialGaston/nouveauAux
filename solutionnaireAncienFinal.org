#+TITLE: solutionnaire final A14
#+author: frederic boileau
#+email: frederic.boileau@protonmail.com
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="blog.css" />
#+OPTIONS: toc:nil num:nil html-style:nil
#+startup:  inlineimages lognoteclock-out hideblocks


* documents

- [[file:ift1016_official_docs/A14-IFT1015-final.pdf][final a14]] ::  pdf

* echauffement (14 points)
:PROPERTIES:
:header-args: :results table
:END:

** a

#+begin_src js
let a=1,b=3;
console.log(a+b+"+"+b+a ,"=",2*(a+b))
#+end_src

#+RESULTS:
| 4+31 = 8 |

Ici il faut faire attention à deux choses: /les règles de préscéance des
opérateurs/, ainsi que les cast implicite fait par javascript lorsqu'un
opérateur agit sur deux éléments de différent type, e.g. =2.0 + "a"=

Lorsque nous avons une expression un peu longue et farfelue l'important est de
déterminer avant tout la préséance des opérateurs si elle n'est pas apparente
immédiatement.

#+BEGIN_SRC js
(a + b + "+" + b + a, "=", 2*(a + b))
(((((a)+ b)+ "+") + b) + a)
#+END_SRC

=a= et =b= seront donc additionnés comme des nombres mais par la suite le
résultat de cette addition sera convertit en string par js pour être
*concaténné* avec le caractère plus.

Le résultat intermédiaire additionné au second b (l'avant dernier terme) est
donc une chaîne de caractère. Le 3 est donc concatenné au 1 ce qui donne
l'impression de l'équation absurde.



** b


#+begin_src js
let a=1,b=3;
console.log(a/b);
#+end_src

#+RESULTS:
| 0.3333333333333333 |

La deuxième ligne du programme demande à l'ordinateur
d'imprimer le ratio de deux nombres entiers ce qui donne
un nombre à virgule à l'écran; on constate donc que le nombre
`rationel` a/b est converti en nombre à virgule.

** c

#+begin_src js
let a=1,b=3;
console.log(a-b+1-b*a);
#+end_src

Encore une fois on est mieux de se mettre des parenthèses pour se convaincre de
la préséance des opérateurs.


La multiplication et la division /brisent/ en quelque sorte les parenthèses qui
s'associent à gauche en définissant l'ordre d'application des opérations.

#+BEGIN_SRC js
let a = 1; b = 3;
console.log((((a) - b) + 1) -(b*(a)))
#+END_SRC

#+RESULTS:
| -4 |

et *non*! :

#+BEGIN_SRC js
let a = 1; b = 3;
console.log(((((a) - b) + 1) - b)*a)
#+END_SRC

#+RESULTS:
| -4 |

Ah c'est un cas spécial parce que a est égal à un et donc
sa multiplication ne change rien ...

¯\_(ツ)_/¯

** d

#+begin_src js
let a=1,b=3;
console.log((Math.random() === 1)? true:false);
#+end_src
#+RESULTS:
: false

Premièrement les variables a et b n'ont aucun rapport avec l'appel à la fonction
=log=. Il faut ici se rappeler de la différence entre ~x \== y~ et ~x \=== y~ ;

le premier opérateur (~==~) teste pour /l'équivalence/ alors que le deuxième
opérateur (~===~) teste pour l'égalité.

par exemple:
#+BEGIN_SRC js :results verbatim
console.log("2" == 2);
console.log("2" === 2);
#+END_SRC

#+RESULTS:
: true
: false


- note :: il faudrait se rappeler que
#+BEGIN_SRC js
2 + "2" === "2" + 2 === "22"
#+END_SRC
je vois mal comment deviner


** e

#+begin_src js :results verbatim
let a=1,b=3;
console.log([a,"b",b]);
#+end_src

#+RESULTS:
: [ 1, 'b', 3 ]

** f

#+begin_src js :results verbatim
var t = [1,2,3];
var r = [5,6,7];
let quiz = function(r,t) {
    r = t;
    t[1] = r[2];
    console.log(t);
    return r;
};

var t = [1,2,3];
var r = ["a", "b", "c"];
var s = quiz(t,r);
console.log(quiz(f,q));
#+end_src

Un nombre de points importants:

 1. les noms des /paramètres/ des fonctions  sont *protégés* du reste du
    programme. par exemple dans `var s = quiz(t,r)` les variables t et r
    sont associées à leurs paramètres respectifs *uniquement en fonction
    de leur position dans l'appel de la fonction*.

    Ainsi pour bien lire la ligne =var s = quiz(t,r)= il faut surtout
    se rappeler que =t= n'était qu'une variable pour le tableau =[1,2,3]=.
    La fonction va donc /binder/ ou assigner la *valeur* =[1,2,3]= , au
    paramètre =r=, et l'autre à l'autre ... , pour ensuite exécuter la fonction
    avec ces nouvelles valeurs concrètes en place des paramètres.

 2. La ligne =r = t;= ne fait pas ce que la majorité de vous pensez. Puisque
    =t= est un tableau c'est un conteneur. Lorsque l'on copie un conteneur
    on peut soit copier uniquement le conteneur, ou alors copier le conteneur
    *et* faire une copie de chaque élément qui se trouvait dans =t=. Pour bien
    sur par la suite les diposés dans le nouveau conteneur.

    *Ainsi, après le statement =r = t;= =r= est maintenant un nouveau conteneur
    mais qui contient les mêmes éléments que =t= !* Modifier un élément qui est
    dans =r= va donc modifier son homologue dans =t=.

#+RESULTS:
#+begin_src js :results verbatim
var t = [1,2,3];
var r = ["a","b","c"];
let quiz = function(r,t) {
    r = t;
    t[1] = r[2];
    return r;
};

var s = quiz(t,r);

console.log(t);
console.log(r);
s[1] = 5;
console.log("t=",t,"r=",r,"s=",s);
#+end_src

#+RESULTS:
: [ 1, 2, 3 ]
: [ 'a', 'c', 'c' ]
: t= [ 1, 2, 3 ] r= [ 'a', 5, 'c' ] s= [ 'a', 5, 'c' ]
: undefined

** -Boucles simples (a) (6 points)
Écrire une fonction loop qui tire aléatoirement des nombres entiers entre O et
10 0 (inclus).
Les tirages s'arrêtent lorsque la valeur 0 est tirée;

#+begin_src js :results verbatim
let gen = function(range){return Math.floor((range*Math.random()));};
let x = gen(10);
var tableau = [x];
while (x != 0){
    x = gen(10);
    tableau.push(x);
};
console.log(tableau);
let stats function(tableau) {
   // le nombre de tirages non nuls réalisés,


}
#+end_src

#+RESULTS:
: [
:   4, 3, 7, 7, 6,
:   2, 8, 2, 3, 9,
:   1, 0
: ]
: 2


et la
fonction affiche selon lexemple donné ci-après:
• le nombre de tirages non nuls réalisés,

• le nombre d'entiers pairs tirés (la valeur 0 n'est pas comptée) et
le pourcentage que cela représente par rapport au nombre total de tirages non
nuls,


• la moyenne des entiers impairs. Pour les tirages successifs: 1 5 3 69 56 0,
l'affichage suivant doit être produit: 5 tirages >O, nbpairs: 1 (20.00%) moy
pairs: 56.00 moy impairs: 26.80

#+begin_src js

#+end_src
